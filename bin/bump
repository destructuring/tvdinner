#!/bin/bash

#/ NAME
#/     bump -- increments a semver in a file or in git tags
#/
#/ SYNOPSIS
#/     bump [major|minor|patch]
#/     bump 1.2.3
#/     bump
#/       without arguments is equivalent to 'bump patch'

# figure out the project root under which bin, lib live
shome="$(cd -P -- "$(dirname -- "$0")/.." && pwd -P)"

# load a meat library
source "$shome/bin/_prime" "$@"

function bump_version {
  ensure_clean_git_status

  local_file=
  if [[ -f VERSION || -L VERSION ]]; then
      local_file=1
    if [[ ! -e VERSION ]]; then
      echo "ERROR: cannot write to VERSION file" 1>&2
      exit 1
    fi
  fi

  tmp_version=$(mktemp -t XXXXXXXXX)
  if [[ -n $local_file ]]; then
    cat VERSION | perl -ne 'm{^\s*v?(\d+)\.(\d+)\.(\d+)\s*$} && printf("%03d.%03d.%03d %d.%d.%d\n",$1,$2,$3,$1,$2,$3)' | sort -r | head -1 | awk '{print $2}' > $tmp_version
  else
    git tag | perl -ne 'm{^v(\d+)\.(\d+)\.(\d+)$} && printf("%03d.%03d.%03d %d.%d.%d\n",$1,$2,$3,$1,$2,$3)' | sort -r | head -1 | awk '{print $2}' > $tmp_version
  fi

  case "$1" in
    patch|minor|major)
      bump=$1; shift
      set -- $(cat $tmp_version | sed 's#\.# #g')
      case "$bump" in
        patch)
          echo "$1.$2.$(($3 + 1))"
          ;;
        minor)
          echo "$1.$(($2 + 1)).0"
          ;;
        major)
          echo "$(($1 + 1)).0.0"
          ;;
      esac > $tmp_version
      ;;
    *)
      ver_new=$1; shift
      ver_new=${ver_new#v}
      echo $ver_new > $tmp_version
      ;;
  esac

  ver_new=$(cat $tmp_version)
  set -- $(echo "$ver_new" | sed 's#\.# #g') 0
  M=$1; shift
  m=$1; shift
  p=$1; shift

  (echo "$(($M+0)).$(($m+0)).$(($p+0))" > $tmp_version) 2>&-
  ver_new_same=$(cat $tmp_version)

  if [[ $ver_new != $ver_new_same ]]; then
    echo "ERROR: invalid version: $ver_new" 1>&2
    exit 1
  fi

  ver_bumped="v$(cat $tmp_version)"
  rm -f $tmp_version
  ensure_git_tag_available $ver_bumped

  if [[ -n $local_file ]]; then
    echo ${ver_bumped#v} > VERSION
    git add VERSION
    if [[ -f Gemfile ]]; then
      bundle check 2>&1 >/dev/null || { bundle --quiet install --local --path vendor/bundle || bundle check > /dev/null; }
      git add Gemfile.lock
    fi

    git commit -m "bump: $ver_bumped"
    git push
  fi

  git_tag "$ver_bumped"
  echo $ver_bumped
}

function ensure_git_tag_available {
  version=$1; shift
  git fetch --tags
  remote_sha=$(git ls-remote origin $version | awk '{print $1}')
  if [[ -n $remote_sha ]]; then
    echo "ERROR: already a remote tag $version, bump again" 1>&2
    exit 1
  fi

  local_sha=$(git show-ref $version | awk '{print $1}')
  if [[ -n $local_sha ]]; then
    echo "ERROR: already a local tag $version" 1>&2
    exit 1
  fi
}

function git_tag {
  local version=$1; shift

  ensure_git_tag_available "$version"

  git tag $version
  git push origin tag $version
  remote_sha=$(git ls-remote origin $version | awk '{print $1}')
  local_sha=$(git show-ref $version | awk '{print $1}')
  if [[ $remote_sha != $local_sha ]]; then
    echo "ERROR: remote tag $version does not match local SHA" 1>&2
    exit 1
  fi
}

function ensure_clean_git_status {
  local lines=$(git status -s -uno | wc -l | awk '{print $1}')
  if [[ $lines != "0" ]]; then
    echo "ERROR: git status is not clean, cannot tag" 1>&2
    git status -s -uno
    exit 1
  fi
}

# entry point
function main {
  bump_version "$@"
}

# parse the command-line
DEFINE_string 'name' "$(basename "$shome")" 'name of gem' 'n'
parse_command_line "$@" || exit $?
eval set -- "${FLAGS_ARGV}"

if [[ "$#" = 0 ]]; then
  set -- patch
fi

# pass arguments to entry point
main "$@"
